h1 заголовок первого уровня
=====================
h2 заголовок второго уровня
-----------------------------------
### h3 заголовок третьего уровня
#### h4 заголовок четвёртого уровня
##### h5 заголовок пятого уровня
###### h6 заголовок шестого уровня


[multi-read] Атомарное чтение из n ячеек

Покажите, что атомарное чтение сразу из n ячеек (вместе с обычными операциями чтения/записи одной ячейки) имеет число консенсуса 1.
---
'''int main() {

int a = 42;

printf("%d\n", a);

return 0;

}
     Доказательство аналогично приведенному на лекции для Read + Write.  
Предположим противное: пусть число консенсуса >= 2, т.е. существует wait-free алгоритм, который для m >= 2 потоков, используя только чтение и запись ячеек памяти (многих и одной соответственно), возвращает одно всем потокам одно из предложенных ими значений за конечное число шагов.   
Введём понятие конфигурации — m (где m — число потоков) троек вида (IP_i, LocalMem_i, GlobalMem_i), где
  -IP_i — Instruction Pointer i-го потока (указывает на ту команду, которую i-ый поток выполнит следующей)
  -LocalMem_i — состояние ячеек памяти, видимых только i-м потоком
  -GlobalMem_i — состояние ячеек памяти, видимых всеми потоками

Тогда исполнение алгоритма можно представить в виде ориентированного графа, такого что его вершинами будут конфигурации, а переходы задаются действиями потоков.  

Докажем, что уже для двух потоков, предлагающих значение 0 или 1 предположение о существовании алгоритма поиска консенсуса приводит к противоречиям. Отсюда будет следовать, что число консенсуса равно 1.   

Классифицируем вершины полученного графа: если все исполнения с началом в данной вершине приводят к одному и тому же ответу алгоритма поиска консенсуса, то назовём её **унивалентной**, а оставшиеся — **бивалентными**. Назовём конфигурацию **критической**, если сама она бивалентна, а все её потоки унивалентны. В случае двух потоков, когда исходящая степень каждой вершины не превосходит двух, это означает, что переход по первому ребру даст, например, 0, а по второму — 1.  

Докажем, что в графе есть критическая конфигурация. Корень — начальная конфигурация — очевидно, бивалентный, т.к. должно быть исполнение, в котором алгоритм возвращает и другое значение. Если начальная конфигуация является критической, то всё доказано. Иначе из него есть переход в бивалентную вершину. Поскольку граф конечный (в силу требования wait-freedom: за конечное число шагов оба потока должны завершить работу), мы не можем сколь угодно долго переходить в поддерево. Значит, за конечное количество шагов критическая конфигурация находится.  

Покажем теперь, что на оба перехода, ведущих из критической конфигурации, должны соответствовать операциям записи. Действительно, если поток T1 читает, то выполним эту инструкцию и дальше будем запускать только поток Т2. Поскольку для Т2 конфигурации до и после записи неразличимы, по завершении работы алгоритм выдаст значение 1. Если же сначала выполнить запись в Т2, а потом чтение в Т1, то придём в ту же итоговую конфигурацию. Аналогично доказывается, что не может быть такого, чтобы переходы соответствовали записи в разные ячейки памяти, т.к. эти переходы тоже коммутируют (если рисовать, то получается эдакий ромбик). Значит, из критической конфигурации выходят рёбра, соответствующие записи в одну и ту же ячейку. Но тогда мы можем сначала запустить Т1 на 1 шаг, а потом Т2, который затрёт значение, записанное Т1. Если затем выполнять только Т2, то алгоритм вернёт 1, а это противоречит тому, что найденное состояние критическое. В результате получаем, что критических конфигураций нет. Из этого наблюдения можно построить исполнение, при котором какой-то из потоков будет ожидать бесконечно долго: достаточно другим потоком всё время идти в бивалентную конфигурацию. Отсюда следует, что такой алгоритм не может быть wait-free. Значит, исходное предположение о числе консенсуса неверно.  

Значит, число консенсуса для Read + Write равно 1.  
Заметим, что неважно, сколько ячеек памяти одновременно мы умеем читать, поскольку это не меняет наблюдаемого другим потоком состояния системы и не запрещает сценарией, описанный выше.


-----------------------------------------------------------------------------------------------

### `[multi-write]` Атомарная запись в $`n`$ ячеек

Рассмотрим операцию `Multi-Write`$`(r_1, v_1, r_2, v_2, ..., r_n, v_n)`$, которая атомарно записывает значения $`v_1, v_2, ..., v_n`$ в ячейки $`r_1, r_2, ..., r_n`$ соответственно. 

1. Покажите, что `Multi-Write` в две ячейки памяти позволяет решить консенсус для двух потоков.

2. Докажите, что `Multi-Write` в $`n`$ ячеек памяти вместе с обычными точечными чтениями/записями позволяет решить консенсус по крайней мере для $`n`$ потоков.

---

Пронумеруем все потоки в каком-нибудь порядке и рассмотрим их всевозможные неупорядоченные пары. Будем использовать $`\binom{n}{2} + n + 1`$ проинициализированных нулями ячеек памяти, по суммарному числу потоков и пар с поправкой на 1-индексацию потоков. 

Вызывая `decide`, поток с номером $`i`$ записывает во все n связанных с ним ячеек свой номер. Поскольку `Multi-Write` — атомарная операция, а модель памяти гарантирует наличие глобального порядка на атомиках, можно задать порядок исполнения потоков, используя в качестве точки линеаризации `Multi-Write`. Пусть потоки выполнились в порядке i_1, ..., i_n. Рассмотрим множество V значений, записанных в парах вида $`(1, k), k > 1`$. Утверждается, что $`\{1, ..., n\} \setminus V`$ содержит только номер потока, первым сделавшего Multi-Write, т.е. $`\{1, ..., n\} = \setminus V = \{ i_1 \}`$. В самом деле, `Multi-Write` в $`i_j`$-м потоке перепишет значение $`(1, i_j)`$. Следовательно, в самом конце все значения, записанные первым `Multi-Write`, будут перезаписаны, что позволяет однозначно определить $`i_1`$. Значение, предложенное потоком $`T_{i_1}`$ вернём в качестве ответа.

То есть операция `Multi-Write`$`(r_1, v_1, r_2, v_2, ..., r_n, v_n)`$ позволяет решить задачу по крайней мере для $`n`$ потоков.
Decide будет возвращать всем потокам значение, предложенное потоком, сделавшим первый `Multi-Write`, то есть `Agreement` и `Validity` выполняются.
Так как в реализации нет циклов, то `Wait-Free Termination` также выполняется.

------------------------------------------------------------


